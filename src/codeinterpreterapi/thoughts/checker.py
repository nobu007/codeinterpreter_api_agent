from json import JSONDecodeError
from typing import Optional, Tuple

import spacy
from langchain.prompts import PromptTemplate
from langchain_core.output_parsers import JsonOutputParser, StrOutputParser
from langchain_core.runnables import Runnable
from langchain_experimental.tot.checker import ToTChecker
from langchain_experimental.tot.thought import ThoughtValidity
from spacy import Language

from codeinterpreterapi.llm.llm import prepare_test_llm
from codeinterpreterapi.thoughts.base import MyToTChain
from codeinterpreterapi.thoughts.thought_generation import (
    MyProposePromptStrategy,
    MyProposePromptStrategyJa,
    MySampleCoTStrategy,
    MySampleCoTStrategyJa,
)

sudoku_puzzle_sample = "3,x,x,x|1,x,3,x|x,1,x,3|4,x,x,1"
sudoku_puzzle = "3,x,x,x|1,x,3,x|x,1,x,3|4,x,x,1"
sudoku_solution = "3,4,1,2|1,2,3,4|2,1,4,3|4,3,2,1"
sudoku_problem_description = f"""
### problem
次の数独パズルを解いてください。

sudoku_puzzle:
{sudoku_puzzle}

### description

これは有効な4x4の数独パズルを表す文字列です。この初期パズルは、数独のルールに完全に従っています。

パズルには1から4までの数字を使用します。
xは、空欄を表す特別な記号です。xを1から4のいずれかの数字で埋めてください。
パイプ文字(|)は行の区切りを表しています。

例えば、
1,2,3,4|2,3,4,1|3,4,1,2|4,1,2,3

は、以下の4x4の数独パズルを表しています。
1,2,3,4
2,3,4,1
3,4,1,2
4,1,2,3

パズルでは各行、各列、各2x2サブグリッドで数字が重複してはいけません。

ルールの詳細です。
a) 各行の|で区切られた4つの数字に、1から4の数字がそれぞれ一度だけ出現しなければなりません。
b) 各列でも、縦に見たときの4つの数字に、1から4の数字がそれぞれ一度だけ出現しなければなりません。
c) 4つの2x2サブグリッドのそれぞれにおいても、1から4の数字がそれぞれ一度だけ出現しなければなりません。
d) xは数字ではないため、重複してはいけない数字に含まれません。
e) xが1つも残ってない状態になればクリアです。

解答を進める際は、前の有効な解答で確定した数字の位置は変えないでください。

""".strip()


#######
# The following code implements an LLM-based checker
#######

checker_prompt = """
## Order
You are a Three-of-Thought (ToT) strategy correctness checker.
As an expert in this genre, you can make accurate judgments without missing even the slightest information.

Based on the problem and thoughts, please judge the correctness of the latest thought (only one).

## Problem Description
### problem
{problem_description}

## Solution Attempt
The following is the Thought generated by the answering LLM.

{thoughts}

## Output
Evaluate whether this answer is correct or not and output in the following format.

```json
{
  "judgement": "VALID_FINAL|VALID_INTERMEDIATE|INVALID"
  "explanation": judgementを選択した理由
}
```

Choose one of the following for <judgement>:
- VALID_FINAL: The answer is completely correct, and the puzzle is solved.
- VALID_INTERMEDIATE: The answer is partially correct but not yet complete.
- INVALID: The answer violates the rules or has obvious errors.

In <explanation>, explain in detail the reason for choosing the judgement. Especially in the case of INVALID, point out specifically which rule is violated or where the error is.

When evaluating the answer, strictly follow the rules shown in the Problem Description.

Please again, pay deep attention for details. Think step by step. Answer correctly.
"""

checker_prompt_ja = """
        ## Order
        あなたはThree-of-Thought (ToT) 戦略の正誤チェッカーです。
        問題と思考から、最新の思考(1つ)について正誤判断をしてください。

        ## Problem Description
        {problem_description}

        ## Solution Attempt
        以下は、回答LLMが生成したThoughts(思考列)です。

        ### IMPORTANT! please check this section ###
        {thoughts}
        ### IMPORTANT! please check this section ###

        ## Support analysis result
        以下は、サポートLLMが生成した解析結果です。

        {support_result}

        ## Output
        この解答が正しいかどうかを評価し、以下のフォーマットで出力してください。

```json
{{
  "judgement": "VALID_FINAL|VALID_INTERMEDIATE|INVALID"
  "explanation": judgementを選択した理由
}}
```

        judgementの選択基準を以下に示します。
        - VALID_FINAL: 思考が完全に正しい場合、現時点で必要な思考がなされた場合。
        - VALID_INTERMEDIATE: 思考は部分的に正しいが、まだ完全ではない場合。
        - INVALID: 思考がルールに違反しているか、明らかな誤りがある場合。ループが発生した場合。

        judgementを選択した理由は特に、INVALIDの場合に具体的にどのルールに違反しているか、どこに誤りがあるかを指摘してください。
        解答の評価を行う際は、Problem Descriptionで示されたルールに厳密に従ってください。
        """

checker_support_prompt_ja = """
        ## Order
        あなたはThree-of-Thought (ToT) 戦略の正誤チェッカーのサポートツールです。

        問題と思考から、最新の思考(1つ)を正誤判断するための明確な判断基準を最大10個の箇条書きで整理してください。
        判断基準は「～であること。」や「～でないこと。」というOK/NGを明示する形式で書いてください。
        「～を確認する」や「～を判断する」という形式では書かないでください。

        ## Problem Description
        {problem_description}

        ## Solution Attempt
        以下は、回答LLMが生成したThoughts(思考列)です。

        {thoughts}

        ## Output
        以下に判断基準を示します。

        """


class MyToTChecker(ToTChecker):
    llm: Optional[Runnable] = None
    prompt: PromptTemplate = PromptTemplate(
        input_variables=["problem_description", "thoughts", "support_result"],
        template=checker_prompt_ja,
    )
    prompt_support: PromptTemplate = PromptTemplate(
        input_variables=["problem_description", "thoughts"],
        template=checker_support_prompt_ja,
    )
    nlp: Language = spacy.load("en_core_web_md")

    def evaluate(self, problem_description: str, thoughts: Tuple[str, ...] = ()) -> ThoughtValidity:
        thoughts = self.pre_evaluate(thoughts)
        # print("MyToTChecker thoughts=", thoughts)

        support_result = self.prompt_support | self.llm | StrOutputParser()
        support_result = support_result.invoke({"problem_description": problem_description, "thoughts": thoughts})
        # print("MyToTChecker support_result=", support_result)

        evaluation = self.prompt | self.llm | JsonOutputParser()
        # print(
        #     "prompt_item=",
        #     self.prompt.invoke(
        #         {"problem_description": problem_description, "thoughts": thoughts, "support_result": support_result}
        #     ),
        # )
        evaluation_output = evaluation.invoke(
            {"problem_description": problem_description, "thoughts": thoughts, "support_result": support_result}
        )
        print("MyToTChecker evaluation_output=", evaluation_output)
        final_judge = self.judge_llm_output(evaluation_output)
        print("MyToTChecker final_judge=", final_judge)
        return final_judge

    def pre_evaluate(self, thoughts: Tuple[str, ...]) -> str:
        thoughts_str = ""
        for i, thought in enumerate(thoughts):
            thoughts_str += f"thought_{i}: "
            thoughts_str += thought
            thoughts_str += "\n"
        return thoughts_str

    def judge_llm_output(self, llm_output) -> ThoughtValidity:
        llm_output_judgement = str(llm_output)
        try:
            llm_output_judgement = llm_output["judgement"]
            # llm_output_explanation = llm_output["explanation"]
            thought_validity_candidates = ["VALID_FINAL", "VALID_INTERMEDIATE", "INVALID"]
            for thought_validity in thought_validity_candidates:
                if thought_validity in llm_output_judgement:
                    return self.get_thought_validity(thought_validity)
        except JSONDecodeError:
            pass

        # nlp judge
        actual = self.nlp(llm_output_judgement)
        options_nlp = ["FINAL", "INTERMEDIATE", "INVALID"]
        similarities = [actual.similarity(self.nlp(option)) for option in options_nlp]
        print("MyToTChecker similarities=", similarities)
        best_match_index = similarities.index(max(similarities))
        best_match = thought_validity_candidates[best_match_index]

        print(f"MyToTChecker Best match: {best_match} with similarity {similarities[best_match_index]}")
        return self.get_thought_validity(best_match)

    def get_thought_validity(self, thought_validity) -> ThoughtValidity:
        if thought_validity == "VALID_FINAL":
            return ThoughtValidity.VALID_FINAL
        elif thought_validity == "VALID_INTERMEDIATE":
            return ThoughtValidity.VALID_INTERMEDIATE
        else:
            return ThoughtValidity.INVALID


#######
# Testing the MyChecker class above:
#######
def test_checker():
    llm, llm_tools = prepare_test_llm()
    tot_chain = create_tot_chain_from_llm(llm)
    checker = tot_chain.checker
    assert (
        checker.evaluate(sudoku_problem_description, ("3,x,1,2|1,x,3,x|x,1,x,3|4,x,x,1",))
        == ThoughtValidity.VALID_INTERMEDIATE
    )
    assert (
        checker.evaluate(sudoku_problem_description, ("3,4,1,2|1,2,3,4|2,1,4,3|4,3,2,1",))
        == ThoughtValidity.VALID_FINAL
    )
    assert (
        checker.evaluate(sudoku_problem_description, ("3,4,1,2|1,2,3,4|2,1,4,3|4,3,x,1",))
        == ThoughtValidity.VALID_INTERMEDIATE
    )
    assert checker.evaluate(sudoku_problem_description, ("3,4,1,2|1,2,3,4|2,1,4,3|4,2,3,1",)) == ThoughtValidity.INVALID


#######
# Initialize and run the ToT chain,
# with maximum number of interactions k set to 30 and
# the maximum number of child thoughts c set to 8.
#######


def create_tot_chain_from_llm(llm=None, is_ja=True, is_simple=False):
    checker = MyToTChecker()
    if llm is None:
        llm = prepare_test_llm()
    checker.llm = llm
    if is_ja:
        if is_simple:
            tot_strategy_class = MySampleCoTStrategyJa
        else:
            tot_strategy_class = MyProposePromptStrategyJa
    else:
        if is_simple:
            tot_strategy_class = MySampleCoTStrategy
        else:
            tot_strategy_class = MyProposePromptStrategy

    tot_chain = MyToTChain.from_llm(
        llm=llm,
        checker=checker,
        k=8,
        c=3,
        verbose=True,
        tot_strategy_class=tot_strategy_class,
        verbose_llm=False,
    )
    return tot_chain


def test_create():
    tot_chain = create_tot_chain_from_llm(llm=prepare_test_llm(), is_simple=False)
    tot_chain.run(problem_description=sudoku_problem_description)


if __name__ == "__main__":
    test_checker()
    test_create()
